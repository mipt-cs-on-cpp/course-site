TDD: класс вектора
##################

:date: 2017-11-26 20:10
:lecture_link: https://youtu.be/gnrGWJzBd58

.. default-role:: code
.. contents:: Содержание

Тестирование: зачем оно нужно?
==============================

После того как программа написана, возникает вполне закономерный вопрос: работает ли она? И если работает,
то работает ли она именно так, как от неё этого ожидают?

Для ответа на эти, в общем-то простые на первый взгляд вопросы, программы подвергаются **тестированию**. По сути
тестирование — это процесс исследования работы программы с целью установить, соответствует ли она предъявляемым
требованиям.

Существует достаточное количество различных видов и методик тестирования: модульное, интеграционное, регрессионное и т.д.
Мы же рассмотрим только самый простой из них — **модульное тестирование** (**unit testing**).

Модульное тестирование
======================

Как следует из названия, основная задача модульного тестирования — проверить корректность функционирования отдельных
модулей. При этом под модулем понимается **не** модуль в терминах языка программирования, а некоторый законченный
фрагмент программы: обычно, это функция или класс.

Рассмотрим в качестве примера одну из задач, встречавшихся ранее: написать функцию, заменяющую в строке все вхождения
`'h'` кроме первого и последнего на на `'H'`. Одно из решений может выглядеть так:

.. code-block:: python

   # Пример программы специально приведён на языке Python, потому что на C++ он выглядит слегка пугающе
   def replace(s):
       return s.replace('h', 'H', s.count('h')-1).replace('H', 'h', 1)

И, казалось бы, это вполне правильное решение: сначала мы заменяем все `'h'` кроме последней на `'H'`, а затем заменяем
обратно первую `'H'` на `'h'`. Но на самом деле такое решение работает, но не во всех случаях:

.. code-block:: pycon

   >>> replace('aaa')
   'aaa'
   >>> replace('aaha')
   'aaha'
   >>> replace('aahha')
   'aahha'
   >>> replace('aahhha')
   'aahHha'
   >>> replace('Haahhha')
   'haaHHha'

Вот и ошибка: в последнем случае мы получили `'haaHHha'` вместо `'HaahHha'`. Это и есть несоответствие программы
предъявляемым к ней требованиям: на некоторых (вполне конкретных) входных данных она работает некорректно.

Выполненные нами проверки являются **ручным** тестирование: т.е. выполняются непосредственно человеком. В этой работе
мы напишем тесты, которые будут выполняться автоматически.

Разработка через тестирование
=============================

Одним из распросстранённых подходов к написанию программ вляется подход под названием **«Test-driven development»**
(TDD, разработка через тестирование). Суть этого подхода заключается в том, что **перед** непосредственным написанием
функциональных частей программы пишутся тесты, которые фиксируют интерфейс взаимодействия, а также описывают ожидаемое
поведение. После того, как написаны тесты, начинается процесс написания основной программы, которая считается законченной, когда все тесты успешно  пройдены.

В качестве примера рассмотрим следующий фрагмент:

.. code-block:: cpp

    vector3d v1 = {1, 2, 3};
    vector3d v2 = {1, 2, 3};

    bool test1 = (v1 == v2) && !(v1 != v2);
    assert(test1);

    vector3d v3 = v1 + v2;
    bool test2 = v3 == vector3d(2, 4, 6);
    assert(test2);

    vector3d v4 = v1 - v2;
    bool test3 = v3 == vector3d(0, 0, 0);
    assert(test3);

    vector3d v5;

    bool test4 = v5 == vector3d(0, 0, 0);
    assert(test4);


Несмотря на то, что мы пока даже не знаем, что из себя представляет класс `vector3d`, мы уже можем сделать достаточно большое количество выводов о нём:

.. code-block:: cpp

    // 0. Класс представляет собой реализацию трёхмерного вектора

    // 1. Класс имеет конструктор, который принимает три параметра
    vector3d v1 = {1, 2, 3};
    vector3d v2 = {1, 2, 3};

    // 2. Для класса определены операторы == и != для проверки равенства и неравенства векторов
    bool test1 = (v1 == v2) && !(v1 != v2);
    assert(test1);

    // 3. Для класса определены операторы + и - для выполнения векторного сложения и вычитания
    vector3d v3 = v1 + v2;
    bool test2 = v3 == vector3d(2, 4, 6);
    assert(test2);

    vector3d v4 = v1 - v2;
    bool test3 = v3 == vector3d(0, 0, 0);
    assert(test3);

    // 4. Класс имеет конструктор по умолчанию, который инициализирует вектор нулями
    vector3d v5;

    bool test4 = v5 == vector3d(0, 0, 0);
    assert(test4);

Как мы видим, не любая реализацию класса `vector3d` будет удовлетворять требованиям, описанным выше. Именно это и
подразумевается под фиксацией интерфейса взаимодействия: тесты описывают, **как** именно мы собираемся использовать
класс и **какое** поведение ожидаем от класса.


Библиотека Google Test
======================

Существует большое количество библиотек для тестирования программ, написанных на языке C++ (`CxxTest`__, `QTest`__,
`Boost::Test`__ и др.). В этой работе мы будем использовать библиотеку `Google Test`__.

.. __: http://cxxtest.tigris.org/
.. __: http://doc.qt.io/qt-5/qtest.html
.. __: http://www.boost.org/doc/libs/1_40_0/libs/test/doc/html/index.html
.. __: https://github.com/google/googletest

Эта библиотека предоставляет набор макросов (а также функций и классов) для написания модульных тестов. Рассмотрим
пример написания модульного теста с использованием `Google Test`:

.. code-block:: cpp

   // Подключаем заголовочный файл
   #include <gtest/gtest.h>
   
   // Описываем тест
   // Sample1 — группа, к которой относится тест
   // TestThatPasses — название теста
   //
   // Имя группы название и теста должны быть валидными идентификаторами,
   // при этом они не могут содержать символ подчёркивания.
   // Группа указывается для логического объединения «близких» тестов.
   TEST(Sample1, TestThatPasses)
   {
       // Выполняем проверки при помощи макросов ASSERT_*
       // Все проверки ниже будут успешно пройдены
   
       ASSERT_TRUE(true);
       ASSERT_FALSE(false);
   
       ASSERT_EQ(1, 1);
       ASSERT_EQ("123", "123");
   
       ASSERT_NE(1, 2);
   
       ASSERT_FLOAT_EQ(1.0, 1.0);
   
       ASSERT_LE(1, 2);
       ASSERT_LE(2, 2);
   
       ASSERT_GE(2, 1);
       ASSERT_GE(2, 2);
   }
   
   // Описываем ещё один тест
   TEST(Sample2, TestThatFails)
   {
       // Выполняем проверки при помощи макросов ASSERT_*
       
       ASSERT_FALSE(false);
       // Эта проверка не будет пройдена
       ASSERT_FALSE(true);
   }
   
   int main(int argc, char* argv[])
   {
       // Запускаем все тесты на исполнение
       testing::InitGoogleTest(&argc, argv);
       return RUN_ALL_TESTS();
   }

Вывод программы из примера:

.. code-block:: text

   [==========] Running 2 tests from 2 test cases.
   [----------] Global test environment set-up.
   [----------] 1 test from Sample1
   [ RUN      ] Sample1.TestThatPasses
   [       OK ] Sample1.TestThatPasses (0 ms)
   [----------] 1 test from Sample1 (0 ms total)
   
   [----------] 1 test from Sample2
   [ RUN      ] Sample2.TestThatFails
   /home/student/lab8/gtest_sample.cpp:40: Failure
   Value of: true
     Actual: true
   Expected: false
   [  FAILED  ] Sample2.TestThatFails (0 ms)
   [----------] 1 test from Sample2 (0 ms total)
   
   [----------] Global test environment tear-down
   [==========] 2 tests from 2 test cases ran. (0 ms total)
   [  PASSED  ] 1 test.
   [  FAILED  ] 1 test, listed below:
   [  FAILED  ] Sample2.TestThatFails
   
    1 FAILED TEST

Ниже приведён список небольшой части макросов `ASSERT_*`, которые предоставляет библиотека `Google Test`. Схема работы
всех макросов одинакова: в случае, если утверждение, описываемое макросом, ложно, то геренируется исключение, а тест
помечается как проваленный.

+------------------------------+--------------------------------------------+
| Макрос                       | Эквивалентное утверждение                  |
+==============================+============================================+
| ASSERT_TRUE(v);              | v == true                                  |
+------------------------------+--------------------------------------------+
| ASSERT_FALSE(v);             | v == false                                 |
+------------------------------+--------------------------------------------+
| ASSERT_EQ(val1, val2);       | val1 == val2                               |
+------------------------------+--------------------------------------------+
| ASSERT_NE(val1, val2);       | val1 != val2                               |
+------------------------------+--------------------------------------------+
| ASSERT_LT(val1, val2);       | val1 < val2                                |
+------------------------------+--------------------------------------------+
| ASSERT_LE(val1, val2);       | val1 <= val2                               |
+------------------------------+--------------------------------------------+
| ASSERT_GT(val1, val2);       | val1 > val2                                |
+------------------------------+--------------------------------------------+
| ASSERT_GE(val1, val2);       | val1 >= val2                               |
+------------------------------+--------------------------------------------+
| ASSERT_FLOAT_EQ(val1, val2); | val1 == val2 // с учётом ошибок округления |
+------------------------------+--------------------------------------------+


Класс вектора
=============

Цель данной работы — написать класс вектора, который будет удовлетворять всем требованиям, заданным при помощи заранее
написанных тестов. Порядок выполнения работы:

#. Скачайте `архив`__ с заготовкой работы и распакуйте его.
#. В файлах `vector3d.hpp`__ и `vector3d.cpp`__  допишите реализацию класса вектора, для 
   которой будут проходить все тесты, описанные в файле `vector_tests.cpp`__. К классу вектора предъявляются следующие
   требования:

   * наличие конструктора с параметрами;
   * наличие конструктора по-умолчанию;
   * возможность прямого доступа к полям;
   * поддержка векторного сложения и вычитания;
   * поддержка векторного умножения;
   * поддержка скалярного умножения;
   * поддержка операции умножения на скаляр;
   * наличие метода для вычисления длины;
   * наличие метода для нормализации;
   * поддержка операций проверки равенства и неравенства;
   * наличие перегруженного оператора для вывода в `std::ostream`.

.. __: {filename}/extra/lab13/vector3d-gtest.zip 
.. __: https://github.com/mipt-cs-on-cpp/vector3d/blob/master/vector3d.hpp
.. __: https://github.com/mipt-cs-on-cpp/vector3d/blob/master/vector3d.cpp
.. __: https://github.com/mipt-cs-on-cpp/vector3d/blob/master/vector_tests.cpp

