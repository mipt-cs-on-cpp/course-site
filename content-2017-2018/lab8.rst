Шаблоны. Списки. Итераторы.
###########################

:date: 2017-10-23 09:00
:lecture_link: https://youtu.be/EJxZRLQCLfk

.. default-role:: code
.. contents:: Содержание


Шаблоны
=======

Шаблоны - это расширение языка (в данном случае расширение языка C++ по отношению к языку C), позволяющее автоматизировать работу программиста. С шаблонами уменьшается количество написанного кода, если нужно реализовать аналогичный функционал для различных исходных типов. Например, есть функция, и она должна работать для параметров разного типа. Конечно, можно написать несколько разных функций, или воспользоваться перезагрузкой функций, но шаблоны предоставляют альтернативный путь. Т. е. для функции (или класса) имеется некий формализованный код (шаблон), в который передаются типы, и компилятор на основе этого сам строит рабочий код. 

Рассмотрим применение шаблонов на примере функции `max`. На языке C ее можно реализовать при помощи директивы `#define` препроцессора

.. code-block:: c

    #define max(a,b)    ((a)>(b) ? (a) : (b))

Теперь везде, где нужно найти большое из двух значений можно использовать определенный выше макрос:

.. code-block:: c

    int x = 1;
    int y = 2;
    int z = max(x, y); // z = 2

При использовании макросов следует избегать передачи выражений в качестве аргументов, иначе возможно непредсказуемое поведение. Скомпилируйте код, приведенный ниже и попробуйте обьяснить полученные результаты:

.. code-block:: c

    #include <iostream>

    #define max(a,b)	((a)>(b) ? (a) : (b))
    int main() {
        int x = 1;
        int y = 2;
        int z = max(x++, y++); 
        std::cout << x << ' ' << y << ' ' << z << std::endl;
    }

Шаблоны в C++ - это инструкции, согласно которым создаются локальные версии шаблонированной функции (или класса/структуры) для определенного набора параметров и типов данных.

С использованием шаблонов определение max будет выглядеть так:

.. code-block:: c

    template <typename T> 
    T & max(const T & a, const T & b) {
        return a > b ? a : b;
    }

каждое использование шаблона в коде с новым типом вызовет генерацию компилятором функции с заданным типом. Например:

.. code-block:: c

    int xi = 1;
    int yi = 2;
    int zi = max(xi, yi); // будет сгенерирована и скомпилирвоана функция max(const int & a, const int & b)

    float xf = 1.0f;
    float yf = 2.0f;
    float zf = max(xf, yf); // будет сгенерирована и скомпилирована функция max(const float & a, const float & b)

Использование шаблонов позволяет сократить обьем написанного кода в случае когда одни и те же алгоритмы нужно применить для разных типов данных.

Шаблоны также применяются и при создании классов. Допустим, в программе нужно реализовать два односвязных списка - для строк и целых чисел.

В первом случае каждый узел будет будет описываться структурой 

.. code-block:: c

    struct tNode {
        std::string data;
        tNode* next;
    }; 

во втором 

.. code-block:: c

    struct tNode {
       int data;
       tNode* next;
    }; 


очевидно, что алгоритмы работы над элементами списка не зависят от типа хранимых значений (в данном случае типа поля `data`). Поэтому структуру `tNode` можно описать в виде шаблона:

.. code-block:: c

    template<typename DataType>
    struct tNode {
        DataType data;
        tNode<T>* next;
    };


Обьявление односвязного списка будет выглядеть так:

.. code-block:: c

    template<typename DataType>
    struct List {
       tNode<DataType> *begin;
       int size;
   };


соотвественно функции, выполняющие различные действия над элементами списка тоже должны быть обьявлены как шаблоны:

.. code-block:: c

    template<typename DataType>
    void list_init(List<DataType> & lst)
    {
        lst.begin = nullptr;
        lst.size = 0;
    }

Обьявление переменных будет выглядеть следующим образом:

.. code-block:: c

    List<std::string> stringList;
    List<int> intList;

На стадии компиляции из шаблонов будут сгенерированы структуры `tNode` и `List` соотвествующие типам `std:string` и `int`.


Односвязанный список
====================

Структура `List`, обьявленая выше, содержит указатель на первый элемент списка `begin` и кол-во элементво в списке - `size`. Данная реализация позволяет достаточно просто добавлять элементы в начало списка, поскольку указатель на первый элемент  известен (поле `begin`). Но чтобы добавить элемент в конец, нужно циклом пробежать по всему списку, пока не будет найден последний элемент. 
Другими словами, данная реализация позволяет за `O(1)` операций вставлять элементы в начало и вычислять длину списка (поскольку кол-во элементов хранится в переменной `size`), но при добавлении в конец уже потребуется `O(n)`.

Задание
-------

* Скачайте `заголовочный файл`__ и `пример его использования`__ . Скомпилируйте и запустите программу. 

.. __: ../extra/lab8/linked_list.hpp
.. __: ../extra/lab8/list_app.cpp

* Добавьте поле `end` в структуру `List`, модифицируйте функции, работающие со списком чтобы они корректно заполняли значение этого поля. 
* Реализуйте функцию `list_insert_back`, вставляющую элементы в конец списка. Добавьте цикл, который вставляет числа от 90 до 100 в конец списка.
* Реализуйте функцию `list_insert(List<DataType> & l, int i)`, вставляющую элемент в `i` позицию списка. Вставьте значение -1 в серидину списка.

.. image:: {filename}/images/lab8/insert.png
   :width: 50%


.. |swap_img| image:: {filename}/images/lab8/swap.png
   :width: 50%


.. |swap_1_img| image:: {filename}/images/lab8/swap1.png
   :width: 75%


* Реализуйте функцию bool `list_swap(List<DataType> & l, int i, int j)`` меняющую местами `i` и `j` элементы списка и возвращаующую `true`. Если `i` или `j` выходят за границы списка, функция должна возвращать `false` и не менять содержимое списка. При этом нужно учесть, что возможны два варианта: 

    * заменяемые узлы являются соседями 

|swap_img|

    * заменяемые узлы не являются соседями, то есть между ними имеется хотя бы один элемент 

|swap_1_img|


* Реализуйте функцию `bool list_remove(List<DataType> & l, int i)`` удаляющую `i` элемент списка и возвращающую `true`. Если `i` выходит за границы списка, то функция должна возвращать `false` и не менять содержимое списка. Удалите все четные числа из списка.

.. image:: {filename}/images/lab8/remove.png
   :width: 37%

* Реализуйте функцию `void list_reverse(List<DataType> & l)` которая располагает элементы исходного списка в обратном порядке. Выведите на экран сначаал исходный список, а потом перевернутый.
* Реализуйте функцию `void list_sort(List<DataType> & l)` которая сортирует элементы исходного списка в порядке возрастания используя сортировку пузырьком. Выведите на экран содержимое отсортированного списка.


Итераторы
=========

Главное предназначение итераторов заключается в предоставлении возможности пользователю обращаться к любому элементу контейнера при сокрытии внутренней структуры контейнера от пользователя. Это позволяет контейнеру хранить элементы любым способом при допустимости работы пользователя с ним как с простой последовательностью или списком. 

Итератор похож на указатель своими основными операциями: он указывает на отдельный элемент коллекции объектов (предоставляет доступ к элементу) и содержит функции для перехода к другому элементу списка (следующему или предыдущему). Контейнер, который реализует поддержку итераторов, должен предоставлять первый элемент списка, а также возможность проверить, перебраны ли все элементы контейнера (является ли итератор конечным). В зависимости от используемого языка и цели, итераторы могут поддерживать дополнительные операции или определять различные варианты поведения.


Рассмотрим реализацию простейшего итератора для списка

.. code-block:: c

    template<typename DataType>
    struct ListIterator {
       tNode<DataType> *current;  // Указатель на текущий элемент
    };

   // Функция инициализиции итератора
   template<typename DataType>
   ListIterator<DataType> list_iter_init(List<DataType> & lst) {
       ListIterator<DataType> it;
       it.current = lst.begin;
       return it;
    }

    // Возвращает true если текущий элемент итератора не последний
    template<typename DataType>
    bool list_iter_has_next(ListIterator<DataType> & it) {
        return it.current->next != nullptr;
    }

     // Возвращает значение текущего элемента списка и перескакивает на следующий
    template<typename DataType>
    DataType * list_iter_next(ListIterator<DataType> & it) {
       if ( it.current ) {
            DataType * ptr = & (it.current->data);
            it.current = it.current->next;
            return ptr;
        }
        return nullptr;
    }


И пример использования:

.. code-block:: c

    #include <iostream>

    int main() {
        int i;
        List<int> intList;

        list_init(intList);
        for(i = 0; i < 10; ++i) {
           list_insert(intList, i);
        }

        ListIterator<int> iter = list_iter_init(intList);

        while(list_iter_has_next(iter)) {
           int * v = list_iter_next(iter);
           std::cout << *v << ' ';
        }


Двусвязный линейный список
==========================

Двусвязный линейный список - список, в котором каждый элемент хранит указатель как на следующий так и на предыдущий:

.. code-block:: c

    template<typename DataType>
    struct tNode2 {
        DataType data;
        tNode<DataType>* next;
        tNode<DataType>* prev;
    }

Из декларации `tNode2` следует , что каждый элемент занимает в памяти больше места по сравнению с односвязанным, и каждая операция изменения списка требует большего количества действий, поскольку нужно изменять значения двух указателей - `prev` и `next`. Использование двусвязных списков оправдано, когда требуется перемещаться от текущего элемента в обеих направлениях. 
Описание шаблона двусвязного списка:

.. code-block:: c

    template<typename DataType>
    struct List2 {
        tNode2<DataType> *begin;
        tNode2<DataType> *end;
        int size;
    };

и соотвественно итератора:

.. code-block:: c

    template<typename DataType>
    struct List2Iterator {
        tNode2<DataType> *current;  // Указатель на текущий элемент
    };

для итератора двусвязного списка по аналогии с `list_iter_has_next` и `list_iter_next` можно реализовать функции `list_iter_has_prev` и `list_iter_prev`, позволяющие перемещаться по списку в обратном направлении.

Задание
-------

Реализуйте следующие шаблоны для двусвязного списка, и пример их использования для списка состоящиего из `int`'ов:

* `void list_init(List2<DataType) & lst)`
* `void list_insert(List2<DataType> & lst, const DataType & v)`
* `void list_print(List2<DataType> & lst)`
* `void list_print_inverse(List2<DataType> & lst)`
* `void list_destroy(List2<DataType> & lst)`
* `void list_remove(List2<DataType> & lst, int i)`

Реализуйте следующие шаблоны для итератора двусвязного списка:

* `bool list_iter_has_prev(List2<DataType> & lst)`
* `DataType * list_iter_prev(List2<DataType> & lst)`


