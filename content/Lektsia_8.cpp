Лекция 8.

// ====================================================================

1) Технические детали классов (см. лекцию 7)

-- public|private, class|struct
-- Конструкторы/деструкторы
-- explicit конструкторы
-- Копирование (базовая идея)
-- initializer_list, {}
-- Указатель this
-- static члены класса

// ====================================================================

2) Детали проектирования классов

-- Основные конструкторы (см.лекцию 7)
-- Специальные функции-члены
---- Конструткор по умолчанию (см.лекцию 7)
---- Деструктор (см.лекцию 7)
---- Копирующие операции
---- Перемещающие операции
-- Функции-члены / данные-члены (см.лекцию 7)
-- Операторы 

// ====================================================================

3) Операторы

x+y*z

class complex
{
	complex operator+(complex);
};

1) Инфиксная форма записи a+b
2) Функциональная форма записи a.operator+(b)

->[]() -- тоже можно перегрузить для нашего класса
:: . .* -- нельзя перегрузить
, & -- не рекомендуется перегружать

// ===================================================================

class X
{
	void operator+(int);
	X(int); // non explicit
};

void operator+(X, X);
void operator+(X, double);

X a; a + 1; 1.0f + a; 1 + 1; a + 1.0;
Только 1 пользовательское преобразование
Компилятор имеет право применить встроенное преобразование

// ===================================================================

Тот же идейный синтаксис
+ -- тернарный оператор + нельзя
void operator+(X, X, X);
% -- не может быть унарным оператором
:? -- нельзя перегрузить

// ===================================================================

+ += ++

++ -- +=1
+ -- +=

class X
{
	X & operator+=(X) // op=
	{
		return *this;
	}
};

void operator+(X, X)
{
	// +=
	// x+=y
}

1 + x
x + 1
1 += x; // неприменима
x += 1;
(x += 1).f();

x++;
++x;

// ===================================================================

class X
{
	X(int);
	operator int() { return ...; }
};

void operator+(X, X)

X x;
int result = 1 + x;

// ===================================================================

lvalue | rvalue и references

lvalue -- объект, который занимает идентифицируемое место в памяти
rvalue -- все остальное

int x = 10;
int x = y;

1) идентифицируемость(i)
2) перемещаемость(m)

lvalue(i & !m) --разновидность gvalue
rvalue(m)
gvalue(i) // generalized
xvalue(i & m) // extended | expert only -- разновидность gvalue|rvalue
prvalue(!i & m) // pure -- чистый -- разновидность rvalue

// ===================================================================

references

int x = 10;
int & ref = x;

string && rvr { "hello" }; // для семантики перемещения
const string & lvr = "hello"; // const !

Применимость: destructive read;

int x = 10;
int&& rvr = std::move(x); // move для x делает тип int&&

using rr_i = int&&;
using lr_i = int&;
using rr_rr_i = rr_i && ; // int &&
using lr_rr_i = rr_i & ; // int &
using rr_lr_i = lr_i && ; // int &
using lr_lr_i = lr_i & ; // int &

1) Псевдонимы
2) auto && x = ... // int & x = ...
3) Шаблоны

// ===================================================================

10;

void f(const int & x) // передача
{

}
f(10); // нельзя делать
int x = 10;
f(x);

// идея перемещения
int && rvr = 5;

int & ref = x;

// ===================================================================

copy VS move

int x = 0, y = 10;
x = y; // copy

{
	X x;
	// ...
	f(x); // можно переместить
	// ... -- НЕ ИСПОЛЬЗУЕТСЯ x
}

class X
{
	X(const X& other);
	X& operator=(const X& other);

	X(X&& other);
	X& operator=(X&& other);
};

// X && 
// const X && -- на практике не используется

Свойства копирования:
1) эквивалентность
2) независимость

Компилятор может генерировать спец. ф-члены

class X
{
	int * ptr;
	int length;
	X()
	{
		ptr = new int[length];
	}
	// X& operator=(const X &);
	X& operator=(X&& other)
	{
		this->ptr = other.ptr;
		this->length = other.length;
		other.ptr = nullptr;
		other.length = 0;
	}
};

X x1, x2;
// ... x2
x1 = std::move(x2);
x1.operator=(std::move(x2));

X x1, x2;
x1 = x2; // shallow copy -- поверхностное копирование
(*x2.ptr) = ...

Когда class имеет указатель (или еще что-то особенное)
нужно писать операции самостоятельно

Пользовательский оператор выполняет deep copy

// ===================================================================

void swap(X & a, X & b)
{
	const X tmp = a; // очень много работы на копировании
	a = b;
	b = tmp;
} // выполнить exchange

void swap(X & a, X & b)
{
	X tmp = std::move(a); // static_cast < X&& > (a)
	a = std::move(b);
	b = std::move(tmp);
}

// ===================================================================

Matrix operator+(...)
{
	Matrix result;
	// ...
	return result; // оптимизация !!!
}

Matrix & operator+(...)
{
	Matrix & result = *new Matrix(...);
	// ...
	return result;
}

// delete 