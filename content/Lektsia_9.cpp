Лекция 8

1) Есть польз. к-р, то не ген. к-р по умолчанию

2) Копирующие операции независимы
2.1) Копирующие операции зависимы от перемещения
2.2) C++98 правило зав. от дестркутора отсутствует
2.3) C++11+ Правило добавилось?

3) Перемещающие операции НЕ независимы
3.1) Перемещающие операции зависят от копирующих
3.2) Перемещающие операции от деструктора

Если написали одну операцию, то написать и остальные.

= default, = delete

// ===========================================================

Наследование

Классы и иерархии -> C++ <- Simula

Класс - это концепт, но копцепты зависимы друг от друга

shape
Circle
Triangle

является разновидностью

car
wheel
engine

реализован посредством

Принцип подстановки Лисков

// ===================================================================

Базовый и производные классы

наследование
1) интерфейс  -- каждый произв. класс по своему опр. ф-ии базового
2) реализация -- использование реализации чего-либо из Б.К.

Наследование интерфейса -- полиморфизм времени выполнения

// ===================================================================

class Employee
{
public:
	string name;
	int age;

	Employee(string n, int a) :
		name(n), age(a)
	{}

	virtual void print()
	{
		// ... name ... age
	}

	virtual ~Employee() = default;
private:
protected:
};

class Manager : public Employee // открытое наследование
	// private -- закрытое наследование -- реализован посредством
{
public:
	int group;
	int level;

	Manager(int g, int l, string n, int a) :
		Employee(n, a), group(g), level(l)
	{
		// ... 
	}

	void print() // перекрытие без virtual
	{
		// ... group ... level

		Employee::print(); // явное разрешение имени
	}

	void f()
	{
		group = 1;
		name = "Jenssen";
	}
};

Производный -- derived
Базовый -- base

public: 
со стороны, ф-ии члены данного класса и производных, друзья класса, 

protected:
ф - ии члены данного класса и производных, друзья класса,

private:
	ф - ии члены данного класса, друзья класса, ;

Manager m; // вызван к-р по умолчанию класса Manager

m.group = 10;
m.name = "Igor";

m.print();

// ==================================================================

class A {};
class B : public A {};
class C : public B {};

// ==================================================================

C++ имеет статическую типизацию

int x = 10;
x = "hello";

x = 10; // python, php -- динамическую типизацию

int * ptr;
double * dptr;

dptr = ptr;

// Employee * e = new Employee(...);

Employee * e = new Manager(...);

Base * = Derived *

// ==================================================================

Employee * -- что там внутри?

1) Знание системы типов // знание оракула
2) type_field 
3) dynamic_cast
4) virtual

static_cast
dynamic_cast // + доп. проверки в run time
const_cast
reinterpret_cast // другая интрепретация посл. бит

if (e.type_field == 1)
{
	Manager * m = dynamic_cast <Manager *> (e);
}

// движение по иерархии основано на указателях (либо ссылках)

// ====================================================================

Employee * e = new Manager(...);
Employee * e1 = new Director(...);
Employee * e2 = new Employee(...);

vector < Employee * > v;

v[0]->print();
v[1]->print();
v[2]->print(); // из  Employee, если v[2] - e2

e->print(); // вызов print из Employee (без virtual)
e->print(); // вызов print из Manager (c virtual)

virtual позволяет использовать динамическое связывание или
run - time полиморфизм при условии использования virtual(будет
	корректно работать если у функций в Base и Derived классах
	одинаковые имена и одинаковый тип) и работой
	с Base - Derived через указатели или ссылки

	// ==================================================================

	Employee -- базовый класс

	Абстрактный базовый класс; --класс, который содержит Ч.В.Ф.
	!нельзя создать экземпляр А.Б.К.

	virtual void print() = 0; --это чисто виртуальная функция

	virtual --функция может быть переопр.в производном классе.
	= 0 --функция обязана быть переорпеделена в производном классе.

	// ==================================================================

	Employee * e = new Manager(...)

	// e

	delete e; // вызов дестрекутора для типа Employee

// ====================================================================

struct B
{
	int m;
	static int sm;
};

class D1 : public virtual B {};
class D2 : public virtual B {};
class D12 : public D1, private D2 {};

D12 * pd = new D12;
B * pb = pd;
int i1 = pd->m; // ошибка
int i2 = pd->sm; // ок

Вместо закрытого наследования лучше использовать композицию

class Wheel
{
public:
	void f()
	{
		m++;
	}

private:
	int m;
};

class Car : private Wheel
{
public:
	void g()
	{
		f();
		
	}
};

Car c;
c.g();
c.f();

лучше делать так:

class Car
{
	Wheel w;
};

// ====================================================================
