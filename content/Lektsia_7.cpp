Лекция 7.
- технические детали
- операторы + move
- наследование и иерархии
1. inline namespace
2. namespace { ... } -линковка
3. типы линквоки -- external и internal linkage
extern int x; -- external
const int x; -- internal
4. глобальных объектов нужно избегать!
Порядок инициализации глоб. стат. объектов не определен.

Классы -- UDT
float, +, = ...

Сохранность инварианта. 

Интерфейс: должно быть очень сложно работать неправильно.

1. UDT
2. members (данные и функции)
3. класс - это namespace
4. creation, destruction, copy, move
5. ., ->
6. operator overloading
7. public|private, инкапсуляция
Инкапсуляция, полиморфизм, наследование
8. struct VS class

// ================================================
7-8

class X
{
private:
	int m;
public:
	X(int i) : m{ i } {}

	void f()
	{
		m++;
	}
private:
	int m_2;
};

// protected

X x;
x.m;
x.f();

// =============================================
4 - copy

X x1(6);
X x2(7);
x1 = x2;
X x3(x2);

Специальные ф-ии члены:
1) к-р по умолчанию
1.1) если прописали к-р, то комп. не генер. по умолч.
2) оператор копирующего присваивания
3) конструктор копирования
4) оператор перемещающего присваивания - move
5) конструктор перемещения - move
6) деструктор

class X
{
public:
	int x;
};

// ================================================

1. Основные к-ры и к-р по умолчанию
2. Деструктор -- идиома RAII

class X // идиома RAII
{
	int * ptr;
	int m;
	X() : m(0)
	{
		ptr = new int[10];
	}
	~X()
	{
		delete[] ptr;
	}
};

{
	X x;
	x.ptr ...

		int * ptr = new (p) int[10];

		x.~X(); // placement new
}

// =================================================
Порядок выполнения к - ра(д - ра)

X x;

1. -- вызываются к-ры базовых классов
2. инициализация членов класса
3. выполняется тело к-ра

Деструктора:

1. выполняется тело д-ра
2. уничтожения членов класса
3. -- вызываются д-ры базовых классов

// ===================================================

class X
{
	const int c;

	int x;
	int y {1000}; // значение по умолчанию
	X(int a, int b) : x(a), c(100) { c = 100; }
	X(...) : ... {}
};

X x(1, 2);
X x { 1, 2 };
X x {}; // к-р по умолчанию

! К-р с initializer_list имеет приоритет !

// ===================================================

initializer_list

auto v = { 1 }; // std::initializer_list<int>

{} --фигурная инициализация удобна

X x{}; // X x(); -- объявление ф-ии

std::vector < int > v(10); // вызов к-ра приним. int
std::vector < int > v{10}; // вызов к-ра приним. list

vector(std::initializer_list < T > list)
{
	for (auto x : list)
	{
		std::cout << x;
	}
}

// ===================================================

class X
{
	void f() // по умолчанию inline
	{
		return m;
	}

	void g();
};

void X::g()
{
	...
}

// ===================================================

explicit конструктор

class X
{
	static int s;
	int x;
	int y;
	explicit X(int a, int b) : x(a), y(b) 
	{
		s = 100;
	}
};

X x(10);
X y(20);
X x = { 10,10 }; // неявный вызов к-ра

std::vector < int > v = 10;

x.s = 100;
y.s == 100;

X::s = 100;

Comlex c = 10; // естественно

// ===================================================

указатель this

class X
{
	int m;

	void f([передаем объект])
	{
		[этот переданный объект].m++;

		this // это указатель на данный объект

			(this->m)++;

	}

	X & operator=(const X & x)
	{
		// выполняет копирование
		m = x.m;

		return *this;
	}
};

a = b; // (a.operator=(b)).f()
(a=b)++;

X x;
x.f(); // есть неявный 1-ый аргумент у f